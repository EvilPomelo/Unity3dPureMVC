<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PureMVC</name>
    </assembly>
    <members>
        <member name="T:PureMVC.Core.Controller">
            <summary>
            A Multiton <c>IController</c> implementation.
            </summary>
            <remarks>
            	<para>In PureMVC, the <c>Controller</c> class follows the 
            	'Command and Controller' strategy, and assumes these 
            	responsibilities:</para>
            	<list type="bullet">
            		<item> Remembering which <c>ICommand</c>s 
            		are intended to handle which <c>INotifications</c>.</item>
            		<item> Registering itself as an <c>IObserver</c> with 
            		the <c>View</c> for each <c>INotification</c> 
            		that it has an <c>ICommand</c> mapping for.</item>
            		<item> Creating a new instance of the proper <c>ICommand</c> 
            		to handle a given <c>INotification</c> when notified by the <c>View</c>.</item>
            		<item>Calling the <c>ICommand</c>'s <c>execute</c> 
            		method, passing in the <c>INotification</c>.</item>
            	</list>
            	<para>
            	    Your application must register <c>ICommands</c> with the 
            	    <c>Controller</c>.
            	</para>
            	<para>
            	    The simplest way is to subclass <c>Facade</c>, 
            	    and use its <c>initializeController</c> method to add your 
            	    registrations.
            	</para>
            </remarks>
            <seealso cref="T:PureMVC.Core.View"/>
            <seealso cref="T:PureMVC.Patterns.Observer.Observer"/>
            <seealso cref="T:PureMVC.Patterns.Observer.Notification"/>
            <seealso cref="T:PureMVC.Patterns.Command.SimpleCommand"/>
            <seealso cref="T:PureMVC.Patterns.Command.MacroCommand"/>
        </member>
        <member name="M:PureMVC.Core.Controller.#ctor(System.String)">
            <summary>
            Constructs and initializes a new controller
            </summary>
            <remarks>This <c>IController</c> implementation is a Multiton, 
                so you should not call the constructor 
                directly, but instead call the static Multiton
                Factory method <c>Controller.getInstance(multitonKey, () => new Controller(multitonKey))</c>
            </remarks>
            <param name="key">Key of controller</param>
            <exception cref="T:System.Exception">Thrown if instance for this Multiton key has already been constructed</exception>
        </member>
        <member name="M:PureMVC.Core.Controller.InitializeController">
            <summary>
            Initialize the Multiton <c>Controller</c> instance
            </summary>
            <remarks>
                <para>Called automatically by the constructor</para>
                <para>
                    Please aware that if you are using a subclass of <c>View</c>
                    in your application, you should also subclass <c>Controller</c>
                    and override the <c>initializeController</c> method in the following way:
                </para>
                <example>
                    <code>
                        // ensure that the Controller is talking to my IView implementation
                        public override void initializeController()
                        {
                            view = MyView.getInstance(multitonKey, () => new MyView(multitonKey));
                        }
                    </code>
                </example>
            </remarks>
        </member>
        <member name="M:PureMVC.Core.Controller.GetInstance(System.String,System.Func{PureMVC.Interfaces.IController})">
            <summary>
            <c>Controller</c> Multiton Factory method.
            </summary>
            <param name="key">Key of controller</param>
            <param name="controllerClassRef">the <c>FuncDelegate</c> of the <c>IController</c></param>
            <returns>the Multiton instance of <c>Controller</c></returns>
        </member>
        <member name="M:PureMVC.Core.Controller.ExecuteCommand(PureMVC.Interfaces.INotification)">
            <summary>
            If an <c>ICommand</c> has previously been registered 
            to handle a the given <c>INotification</c>, then it is executed.
            </summary>
            <param name="notification">note an <c>INotification</c></param>
        </member>
        <member name="M:PureMVC.Core.Controller.RegisterCommand(System.String,System.Func{PureMVC.Interfaces.ICommand})">
            <summary>
            Register a particular <c>ICommand</c> class as the handler 
            for a particular <c>INotification</c>.
            </summary>
            <remarks>
                <para>
                    If a <c>ICommand</c> has already been registered to 
                    handle <c>INotification</c>s with this name, it is no longer
                    used, the new <c>Func</c> is used instead.
                </para>
                <para>
                    The Observer for the new ICommand is only created if this the
                    first time an ICommand has been regisered for this Notification name.
                </para>
            </remarks>
            <param name="notificationName">the name of the <c>INotification</c></param>
            <param name="commandClassRef">the <c>Func Delegate</c> of the <c>ICommand</c></param>
        </member>
        <member name="M:PureMVC.Core.Controller.RemoveCommand(System.String)">
            <summary>
            Remove a previously registered <c>ICommand</c> to <c>INotification</c> mapping.
            </summary>
            <param name="notificationName">the name of the <c>INotification</c> to remove the <c>ICommand</c> mapping for</param>
        </member>
        <member name="M:PureMVC.Core.Controller.HasCommand(System.String)">
            <summary>
            Check if a Command is registered for a given Notification 
            </summary>
            <param name="notificationName"></param>
            <returns>whether a Command is currently registered for the given <c>notificationName</c>.</returns>
        </member>
        <member name="M:PureMVC.Core.Controller.RemoveController(System.String)">
            <summary>
            Remove an IController instance
            </summary>
            <param name="key">multitonKey of IController instance to remove</param>
        </member>
        <member name="F:PureMVC.Core.Controller.view">
            <summary>Local reference to View</summary>
        </member>
        <member name="F:PureMVC.Core.Controller.multitonKey">
            <summary>The Multiton Key for this Core</summary>
        </member>
        <member name="F:PureMVC.Core.Controller.commandMap">
            <summary>Mapping of Notification names to Command Class references</summary>
        </member>
        <member name="F:PureMVC.Core.Controller.instanceMap">
            <summary>The Multiton Controller instanceMap.</summary>
        </member>
        <member name="F:PureMVC.Core.Controller.MULTITON_MSG">
            <summary>Message Constants</summary>
        </member>
        <member name="T:PureMVC.Core.Model">
            <summary>
            A Multiton <c>IModel</c> implementation
            </summary>
            <remarks>
                <para>In PureMVC, the <c>Model</c> class provides access to model objects (Proxies) by named lookup</para>
                <para>The <c>Model</c> assumes these responsibilities:</para>
                <list type="bullet">
                    <item>Maintain a cache of <c>IProxy</c> instances</item>
                    <item>Provide methods for registering, retrieving, and removing <c>IProxy</c> instances</item>
                </list>
                <para>
                    Your application must register <c>IProxy</c> instances
                    with the <c>Model</c>. Typically, you use an 
                    <c>ICommand</c> to create and register <c>IProxy</c> 
                    instances once the <c>Facade</c> has initialized the Core actors
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Patterns.Proxy.Proxy"/>
            <seealso cref="T:PureMVC.Interfaces.IProxy" />
        </member>
        <member name="M:PureMVC.Core.Model.#ctor(System.String)">
            <summary>
            Constructs and initializes a new model
            </summary>
            <remarks>
                <para>
                    This <c>IModel</c> implementation is a Multiton, 
                    so you should not call the constructor 
                    directly, but instead call the static Multiton 
                    Factory method <c>Model.getInstance(multitonKey, () => new Model(multitonKey))</c>
                </para>
            </remarks>
            <param name="key">Key of model</param>
            <exception cref="T:System.Exception">Thrown if instance for this Multiton key has already been constructed</exception>
        </member>
        <member name="M:PureMVC.Core.Model.InitializeModel">
            <summary>
            Initialize the Multiton <c>Model</c> instance.
            </summary>
            <remarks>
                <para>
                    Called automatically by the constructor, this 
                    is your opportunity to initialize the Multiton 
                    instance in your subclass without overriding the 
                    constructor
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Core.Model.GetInstance(System.String,System.Func{PureMVC.Interfaces.IModel})">
            <summary>
            <c>Model</c> Multiton Factory method. 
            </summary>
            <param name="key">Key of model</param>
            <param name="modelClassRef">the <c>FuncDelegate</c> of the <c>IModel</c></param>
            <returns>the instance for this Multiton key </returns>
        </member>
        <member name="M:PureMVC.Core.Model.RegisterProxy(PureMVC.Interfaces.IProxy)">
            <summary>
            Register an <c>IProxy</c> with the <c>Model</c>.
            </summary>
            <param name="proxy">proxy an <c>IProxy</c> to be held by the <c>Model</c>.</param>
        </member>
        <member name="M:PureMVC.Core.Model.RetrieveProxy(System.String)">
            <summary>
            Retrieve an <c>IProxy</c> from the <c>Model</c>.
            </summary>
            <param name="proxyName"></param>
            <returns>the <c>IProxy</c> instance previously registered with the given <c>proxyName</c>.</returns>
        </member>
        <member name="M:PureMVC.Core.Model.RemoveProxy(System.String)">
            <summary>
            Remove an <c>IProxy</c> from the <c>Model</c>.
            </summary>
            <param name="proxyName">proxyName name of the <c>IProxy</c> instance to be removed.</param>
            <returns>the <c>IProxy</c> that was removed from the <c>Model</c></returns>
        </member>
        <member name="M:PureMVC.Core.Model.HasProxy(System.String)">
            <summary>
            Check if a Proxy is registered
            </summary>
            <param name="proxyName"></param>
            <returns>whether a Proxy is currently registered with the given <c>proxyName</c>.</returns>
        </member>
        <member name="M:PureMVC.Core.Model.RemoveModel(System.String)">
            <summary>
            Remove an IModel instance
            </summary>
            <param name="key">multitonKey of IModel instance to remove</param>
        </member>
        <member name="F:PureMVC.Core.Model.multitonKey">
            <summary>The Multiton Key for this Core</summary>
        </member>
        <member name="F:PureMVC.Core.Model.proxyMap">
            <summary>Mapping of proxyNames to IProxy instances</summary>
        </member>
        <member name="F:PureMVC.Core.Model.instanceMap">
            <summary>The Multiton Model instanceMap.</summary>
        </member>
        <member name="F:PureMVC.Core.Model.MULTITON_MSG">
            <summary>Message Constants</summary>
        </member>
        <member name="T:PureMVC.Core.View">
            <summary>
            A Multiton <c>IView</c> implementation.
            </summary>
            <remarks>
                <para>In PureMVC, the <c>View</c> class assumes these responsibilities:</para>
                <list type="bullet">
                    <item>Maintain a cache of <c>IMediator</c> instances</item>
                    <item>Provide methods for registering, retrieving, and removing <c>IMediators</c></item>
                    <item>Managing the observer lists for each <c>INotification</c> in the application</item>
                    <item>Providing a method for attaching <c>IObservers</c> to an <c>INotification</c>'s observer list</item>
                    <item>Providing a method for broadcasting an <c>INotification</c></item>
                    <item>Notifying the <c>IObservers</c> of a given <c>INotification</c> when it broadcast</item>
                </list>
            </remarks>
            <seealso cref="T:PureMVC.Patterns.Mediator.Mediator"/>
            <seealso cref="T:PureMVC.Patterns.Observer.Observer"/>
            <seealso cref="T:PureMVC.Patterns.Observer.Notification"/>
        </member>
        <member name="M:PureMVC.Core.View.#ctor(System.String)">
            <summary>
            Constructs and initializes a new view
            </summary>
            <remarks>
                <para>
                    This <c>IView</c> implementation is a Multiton, 
                    so you should not call the constructor 
                    directly, but instead call the static Multiton 
                    Factory method <c>View.getInstance(multitonKey, () => new View(multitonKey))</c>
                </para>
            </remarks>
            <param name="key">Key of view</param>
            <exception cref="T:System.Exception">Thrown if instance for this Multiton key has already been constructed</exception>
        </member>
        <member name="M:PureMVC.Core.View.InitializeView">
            <summary>
            Initialize the Multiton View instance.
            </summary>
            <remarks>
                <para>
                    Called automatically by the constructor, this
                    is your opportunity to initialize the Multiton
                    instance in your subclass without overriding the
                    constructor.
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Core.View.GetInstance(System.String,System.Func{PureMVC.Interfaces.IView})">
            <summary>
            <c>View</c> Multiton Factory method. 
            </summary>
            <param name="key">Key of view</param>
            <param name="viewClassRef">the <c>FuncDelegate</c> of the <c>IView</c></param>
            <returns>the instance for this Multiton key </returns>
        </member>
        <member name="M:PureMVC.Core.View.RegisterObserver(System.String,PureMVC.Interfaces.IObserver)">
            <summary>
                Register an <c>IObserver</c> to be notified
                of <c>INotifications</c> with a given name.
            </summary>
            <param name="notificationName">the name of the <c>INotifications</c> to notify this <c>IObserver</c> of</param>
            <param name="observer">the <c>IObserver</c> to register</param>
        </member>
        <member name="M:PureMVC.Core.View.NotifyObservers(PureMVC.Interfaces.INotification)">
            <summary>
            Notify the <c>IObservers</c> for a particular <c>INotification</c>.
            </summary>
            <remarks>
                <para>
                    All previously attached <c>IObservers</c> for this <c>INotification</c>'s
                    list are notified and are passed a reference to the <c>INotification</c> in
                    the order in which they were registered.
                </para>
            </remarks>
            <param name="notification"></param>
        </member>
        <member name="M:PureMVC.Core.View.RemoveObserver(System.String,System.Object)">
            <summary>
            Remove the observer for a given notifyContext from an observer list for a given Notification name.
            </summary>
            <param name="notificationName">which observer list to remove from </param>
            <param name="notifyContext">remove the observer with this object as its notifyContext</param>
        </member>
        <member name="M:PureMVC.Core.View.RegisterMediator(PureMVC.Interfaces.IMediator)">
            <summary>
            Register an <c>IMediator</c> instance with the <c>View</c>.
            </summary>
            <remarks>
                <para>
                    Registers the <c>IMediator</c> so that it can be retrieved by name,
                    and further interrogates the <c>IMediator</c> for its 
                    <c>INotification</c> interests.
                </para>
                <para>
                    If the <c>IMediator</c> returns any <c>INotification</c>
                    names to be notified about, an <c>Observer</c> is created encapsulating 
                    the <c>IMediator</c> instance's <c>handleNotification</c> method 
                    and registering it as an <c>Observer</c> for all <c>INotifications</c> the
                    <c>IMediator</c> is interested in.
                </para>
            </remarks>
            <param name="mediator">the name to associate with this <c>IMediator</c> instance</param>
        </member>
        <member name="M:PureMVC.Core.View.RetrieveMediator(System.String)">
            <summary>
            Retrieve an <c>IMediator</c> from the <c>View</c>.
            </summary>
            <param name="mediatorName">the name of the <c>IMediator</c> instance to retrieve.</param>
            <returns>the <c>IMediator</c> instance previously registered with the given <c>mediatorName</c>.</returns>
        </member>
        <member name="M:PureMVC.Core.View.RemoveMediator(System.String)">
            <summary>
            Remove an <c>IMediator</c> from the <c>View</c>.
            </summary>
            <param name="mediatorName">name of the <c>IMediator</c> instance to be removed.</param>
            <returns>the <c>IMediator</c> that was removed from the <c>View</c></returns>
        </member>
        <member name="M:PureMVC.Core.View.HasMediator(System.String)">
            <summary>
            Check if a Mediator is registered or not
            </summary>
            <param name="mediatorName"></param>
            <returns>whether a Mediator is registered with the given <c>mediatorName</c>.</returns>
        </member>
        <member name="M:PureMVC.Core.View.RemoveView(System.String)">
            <summary>
            Remove an IView instance
            </summary>
            <param name="key">multitonKey of IView instance to remove</param>
        </member>
        <member name="F:PureMVC.Core.View.multitonKey">
            <summary>The Multiton Key for this Core</summary>
        </member>
        <member name="F:PureMVC.Core.View.mediatorMap">
            <summary>Mapping of Mediator names to Mediator instances</summary>
        </member>
        <member name="F:PureMVC.Core.View.observerMap">
            <summary>Mapping of Notification names to Observer lists</summary>
        </member>
        <member name="F:PureMVC.Core.View.instanceMap">
            <summary>The Multiton View instanceMap.</summary>
        </member>
        <member name="F:PureMVC.Core.View.MULTITON_MSG">
            <summary>Message Constants</summary>
        </member>
        <member name="T:PureMVC.Interfaces.ICommand">
            <summary>
            The interface definition for a PureMVC Command.
            </summary>
            <seealso cref="T:PureMVC.Interfaces.INotification"/>
        </member>
        <member name="M:PureMVC.Interfaces.ICommand.Execute(PureMVC.Interfaces.INotification)">
            <summary>
            Execute the <c>ICommand</c>'s logic to handle a given <c>INotification</c>.
            </summary>
            <param name="Notification">an <c>INotification</c> to handle.</param>
        </member>
        <member name="T:PureMVC.Interfaces.IController">
            <summary>
            The interface definition for a PureMVC Controller.
            </summary>
            <remarks>
                <para>
                    In PureMVC, an <c>IController</c> implementor 
                    follows the 'Command and Controller' strategy, and 
                    assumes these responsibilities:
                    <list type="bullet">
                        <item>Remembering which <c>ICommand</c>s 
                        are intended to handle which <c>INotifications</c>.
                        </item>
                        <item>Registering itself as an <c>IObserver</c> with
                        the <c>View</c> for each <c>INotification</c> 
                        that it has an <c>ICommand</c> mapping for.
                        </item>
                        <item>Creating a new instance of the proper <c>ICommand</c> 
                        to handle a given <c>INotification</c> when notified by the <c>View</c>.
                        </item>
                        <item>Calling the <c>ICommand</c>'s <c>execute</c> 
                        method, passing in the <c>INotification</c>.
                        </item>
                    </list>
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Interfaces.INotification"/>
            <seealso cref="T:PureMVC.Interfaces.ICommand"/>
        </member>
        <member name="M:PureMVC.Interfaces.IController.RegisterCommand(System.String,System.Func{PureMVC.Interfaces.ICommand})">
            <summary>
            Register a particular <c>ICommand</c> class as the handler 
             for a particular <c>INotification</c>.
            </summary>
            <param name="notificationName">the name of the <c>INotification</c></param>
            <param name="commandClassRef">the FuncDelegate of the <c>ICommand</c></param>
        </member>
        <member name="M:PureMVC.Interfaces.IController.ExecuteCommand(PureMVC.Interfaces.INotification)">
            <summary>
            Execute the <c>ICommand</c> previously registered as the
            handler for <c>INotification</c>s with the given notification name.
            </summary>
            <param name="notification">the <c>INotification</c> to execute the associated <c>ICommand</c> for</param>
        </member>
        <member name="M:PureMVC.Interfaces.IController.RemoveCommand(System.String)">
            <summary>
            Remove a previously registered <c>ICommand</c> to <c>INotification</c> mapping.
            </summary>
            <param name="notificationName">the name of the <c>INotification</c> to remove the <c>ICommand</c> mapping for</param>
        </member>
        <member name="M:PureMVC.Interfaces.IController.HasCommand(System.String)">
            <summary>
            Check if a Command is registered for a given Notification 
            </summary>
            <param name="notificationName">whether a Command is currently registered for the given <c>notificationName</c>.</param>
            <returns></returns>
        </member>
        <member name="T:PureMVC.Interfaces.IFacade">
            <summary>
            The interface definition for a PureMVC Facade.
            </summary>
            <remarks>
                <para>
                    The Facade Pattern suggests providing a single
                    class to act as a central point of communication 
                    for a subsystem.
                </para>
                <para>
                    In PureMVC, the Facade acts as an interface between
                    the core MVC actors (Model, View, Controller) and
                    the rest of your application.
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Interfaces.IModel"/>
            <seealso cref="T:PureMVC.Interfaces.IView"/>
            <seealso cref="T:PureMVC.Interfaces.IController"/>
            <seealso cref="T:PureMVC.Interfaces.ICommand"/>
            <seealso cref="T:PureMVC.Interfaces.INotification"/>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.RegisterProxy(PureMVC.Interfaces.IProxy)">
            <summary>
            Register an <c>IProxy</c> with the <c>Model</c> by name.
            </summary>
            <param name="proxy">the <c>IProxy</c> to be registered with the <c>Model</c>.</param>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.RetrieveProxy(System.String)">
            <summary>
            Retrieve a <c>IProxy</c> from the <c>Model</c> by name.
            </summary>
            <param name="proxyName">the name of the <c>IProxy</c> instance to be retrieved.</param>
            <returns>the <c>IProxy</c> previously regisetered by <c>proxyName</c> with the <c>Model</c>.</returns>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.RemoveProxy(System.String)">
            <summary>
            Remove an <c>IProxy</c> instance from the <c>Model</c> by name.
            </summary>
            <param name="proxyName">the <c>IProxy</c> to remove from the <c>Model</c>.</param>
            <returns>the <c>IProxy</c> that was removed from the <c>Model</c></returns>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.HasProxy(System.String)">
            <summary>
            Check if a Proxy is registered
            </summary>
            <param name="proxyName"></param>
            <returns>whether a Proxy is currently registered with the given <c>proxyName</c>.</returns>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.RegisterCommand(System.String,System.Func{PureMVC.Interfaces.ICommand})">
            <summary>
            Register an <c>ICommand</c> with the <c>Controller</c>.
            </summary>
            <param name="notificationName">the name of the <c>INotification</c> to associate the <c>ICommand</c> with.</param>
            <param name="commandClassRef">a reference to the <c>FuncDelegate</c> of the <c>ICommand</c></param>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.RemoveCommand(System.String)">
            <summary>
            Remove a previously registered <c>ICommand</c> to <c>INotification</c> mapping from the Controller.
            </summary>
            <param name="notificationName">the name of the <c>INotification</c> to remove the <c>ICommand</c> mapping for</param>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.HasCommand(System.String)">
            <summary>
            Check if a Command is registered for a given Notification 
            </summary>
            <param name="notificationName"></param>
            <returns>whether a Command is currently registered for the given <c>notificationName</c>.</returns>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.RegisterMediator(PureMVC.Interfaces.IMediator)">
            <summary>
            Register an <c>IMediator</c> instance with the <c>View</c>.
            </summary>
            <param name="mediator">a reference to the <c>IMediator</c> instance</param>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.RetrieveMediator(System.String)">
            <summary>
            Retrieve an <c>IMediator</c> instance from the <c>View</c>.
            </summary>
            <param name="mediatorName">the name of the <c>IMediator</c> instance to retrievve</param>
            <returns>the <c>IMediator</c> previously registered with the given <c>mediatorName</c>.</returns>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.RemoveMediator(System.String)">
            <summary>
            Remove a <c>IMediator</c> instance from the <c>View</c>.
            </summary>
            <param name="mediatorName">name of the <c>IMediator</c> instance to be removed</param>
            <returns>the <c>IMediator</c> instance previously registered with the given <c>mediatorName</c>.</returns>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.HasMediator(System.String)">
            <summary>
            Check if a Mediator is registered or not
            </summary>
            <param name="mediatorName"></param>
            <returns>whether a Mediator is registered with the given <c>mediatorName</c>.</returns>
        </member>
        <member name="M:PureMVC.Interfaces.IFacade.NotifyObservers(PureMVC.Interfaces.INotification)">
            <summary>
            Notify <c>Observer</c>s.
            </summary>
            <remarks>
                <para>
                    This method is left public mostly for backward 
                    compatibility, and to allow you to send custom 
                    notification classes using the facade.
                </para>
                <para>
                    Usually you should just call sendNotification
                    and pass the parameters, never having to 
                    construct the notification yourself.
                </para>
            </remarks>
            <param name="notification">the <c>INotification</c> to have the <c>View</c> notify <c>Observers</c> of.</param>
        </member>
        <member name="T:PureMVC.Interfaces.IMediator">
            <summary>
            The interface definition for a PureMVC Mediator.
            </summary>
            <remarks>
                <para>
                    In PureMVC, <c>IMediator</c> implementors assume these responsibilities:
                    <list type="bullet">
                        <item>Implement a common method which returns a list of all <c>INotification</c>s
                        the <c>IMediator</c> has interest in.</item>
                        <item>Implement a notification callback method.</item>
                        <item>Implement methods that are called when the IMediator is registered or removed from the View</item>
                    </list>
                </para>
                <para>
                    Additionally, <c>IMediator</c>s typically:
                    <list type="bullet">
                        <item>Act as an intermediary between one or more view components such as text boxes or 
                        list controls, maintaining references and coordinating their behavior.</item>
                        <item>In Flash-based apps, this is often the place where event listeners are
                        added to view components, and their handlers implemented.</item>
                        <item>Respond to and generate <c>INotifications</c>, interacting with of
                        the rest of the PureMVC app.</item>
                    </list>
                </para>
                <para>
                    When an <c>IMediator</c> is registered with the <c>IView</c>, 
                    the <c>IView</c> will call the <c>IMediator</c>'s 
                    <c>listNotificationInterests</c> method. The <c>IMediator</c> will 
                    return an <c>Array</c> of <c>INotification</c> names which 
                    it wishes to be notified about.
                </para>
                <para>
                    The <c>IView</c> will then create an <c>Observer</c> object 
                    encapsulating that <c>IMediator</c>'s (<c>handleNotification</c>) method
                    and register it as an Observer for each <c>INotification</c> name returned by 
                    <c>listNotificationInterests</c>.
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Interfaces.INotification"/>
        </member>
        <member name="P:PureMVC.Interfaces.IMediator.MediatorName">
            <summary>
            Get or Set the <c>IMediator</c> instance name
            </summary>
        </member>
        <member name="P:PureMVC.Interfaces.IMediator.ViewComponent">
            <summary>
            Get or Set the <c>IMediator</c>'s view component.
            </summary>
        </member>
        <member name="M:PureMVC.Interfaces.IMediator.ListNotificationInterests">
            <summary>
            List <c>INotification</c> interests.
            </summary>
            <returns> an <c>Array</c> of the <c>INotification</c> names this <c>IMediator</c> has an interest in.</returns>
        </member>
        <member name="M:PureMVC.Interfaces.IMediator.HandleNotification(PureMVC.Interfaces.INotification)">
            <summary>
            Handle an <c>INotification</c>.
            </summary>
            <param name="notification">notification the <c>INotification</c> to be handled</param>
        </member>
        <member name="M:PureMVC.Interfaces.IMediator.OnRegister">
            <summary>
            Called by the View when the Mediator is registered
            </summary>
        </member>
        <member name="M:PureMVC.Interfaces.IMediator.OnRemove">
            <summary>
            Called by the View when the Mediator is removed
            </summary>
        </member>
        <member name="T:PureMVC.Interfaces.IModel">
            <summary>
            The interface definition for a PureMVC Model.
            </summary>
            <remarks>
                <para>
                    In PureMVC, <c>IModel</c> implementors provide
                    access to <c>IProxy</c> objects by named lookup.
                </para>
                <para>
                    An <c>IModel</c> assumes these responsibilities:
                    <list type="bullet">
                        <item>Maintain a cache of <c>IProxy</c> instances</item>
                        <item>Provide methods for registering, retrieving, and removing <c>IProxy</c> instances</item>
                    </list>
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Interfaces.IModel.RegisterProxy(PureMVC.Interfaces.IProxy)">
            <summary>
            Register an <c>IProxy</c> instance with the <c>Model</c>.
            </summary>
            <param name="proxy">an object reference to be held by the <c>Model</c>.</param>
        </member>
        <member name="M:PureMVC.Interfaces.IModel.RetrieveProxy(System.String)">
            <summary>
            Retrieve an <c>IProxy</c> instance from the Model.
            </summary>
            <param name="proxyName"></param>
            <returns>the <c>IProxy</c> instance previously registered with the given <c>proxyName</c>.</returns>
        </member>
        <member name="M:PureMVC.Interfaces.IModel.RemoveProxy(System.String)">
            <summary>
            Remove an <c>IProxy</c> instance from the Model.
            </summary>
            <param name="proxyName"></param>
            <returns>the <c>IProxy</c> that was removed from the <c>Model</c></returns>
        </member>
        <member name="M:PureMVC.Interfaces.IModel.HasProxy(System.String)">
            <summary>
            Check if a Proxy is registered
            </summary>
            <param name="proxyName"></param>
            <returns>whether a Proxy is currently registered with the given <c>proxyName</c>.</returns>
        </member>
        <member name="T:PureMVC.Interfaces.INotification">
            <summary>
            A base <c>INotification</c> implementation.
            </summary>
            <remarks>
                <para>
                    PureMVC does not rely upon underlying event models such 
                    as the one provided with Flash, and ActionScript 3 does 
                    not have an inherent event model.
                </para>
                <para>
                    The Observer Pattern as implemented within PureMVC exists 
                    to support event-driven communication between the 
                    application and the actors of the MVC triad.
                </para>
                <para>
                    Notifications are not meant to be a replacement for Events
                    in Flex/Flash/Apollo. Generally, <c>IMediator</c> implementors
                    place event listeners on their view components, which they
                    then handle in the usual way. This may lead to the broadcast of <c>Notification</c>s to 
                    trigger <c>ICommand</c>s or to communicate with other <c>IMediators</c>. 
                    <c>IProxy</c> and <c>ICommand</c>
                    instances communicate with each other and <c>IMediator</c>s
                    by broadcasting <c>INotification</c>s.
                </para>
                <para>
                    A key difference between Flash <c>Event</c>s and PureMVC
                    <c>Notification</c>s is that <c>Event</c>s follow the 
                    'Chain of Responsibility' pattern, 'bubbling' up the display hierarchy 
                    until some parent component handles the <c>Event</c>, while
                    PureMVC <c>Notification</c>s follow a 'Publish/Subscribe'
                    pattern. PureMVC classes need not be related to each other in a 
                    parent/child relationship in order to communicate with one another
                    using <c>Notification</c>s.
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Interfaces.IView"/>
            <seealso cref="T:PureMVC.Interfaces.IObserver"/>
        </member>
        <member name="P:PureMVC.Interfaces.INotification.Name">
            <summary>
            Get the name of the <c>INotification</c> instance. 
            No setter, should be set by constructor only
            </summary>
        </member>
        <member name="P:PureMVC.Interfaces.INotification.Body">
            <summary>
            Get or Set the body of the <c>INotification</c> instance
            </summary>
        </member>
        <member name="P:PureMVC.Interfaces.INotification.Type">
            <summary>
            Get or Set the type of the <c>INotification</c> instance
            </summary>
        </member>
        <member name="M:PureMVC.Interfaces.INotification.ToString">
            <summary>
            Get the string representation of the <c>INotification</c> instance
            </summary>
            <returns>String representation</returns>
        </member>
        <member name="T:PureMVC.Interfaces.INotifier">
            <summary>
            A Base <c>INotifier</c> implementation.
            </summary>
            <remarks>
                <para>
                    <c>MacroCommand, Command, Mediator</c> and <c>Proxy</c> 
                    all have a need to send <c>Notifications</c>.
                </para>
                <para>
                    The <c>INotifier</c> interface provides a common method called
                    <c>sendNotification</c> that relieves implementation code of 
                    the necessity to actually construct <c>Notifications</c>.
                </para>
                <para>
                    The <c>Notifier</c> class, which all of the above mentioned classes
                    extend, provides an initialized reference to the <c>Facade</c>
                    Multiton, which is required for the convienience method
                    for sending <c>Notifications</c>, but also eases implementation as these
                    classes have frequent <c>Facade</c> interactions and usually require
                    access to the facade anyway.
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Interfaces.IFacade"/>
            <seealso cref="T:PureMVC.Interfaces.INotification"/>
        </member>
        <member name="M:PureMVC.Interfaces.INotifier.SendNotification(System.String,System.Object,System.String)">
            <summary>
            Send a <c>INotification</c>.
            </summary>
            <remarks>
                <para>
                    Convenience method to prevent having to construct new 
                    notification instances in our implementation code.
                </para>
            </remarks>
            <param name="notificationName">the name of the notification to send</param>
            <param name="body">the body of the notification (optional)</param>
            <param name="type">the type of the notification (optional)</param>
        </member>
        <member name="M:PureMVC.Interfaces.INotifier.InitializeNotifier(System.String)">
            <summary>
            Initialize this INotifier instance.
            </summary>
            <remarks>
                <para>
                    This is how a Notifier gets its multitonKey. 
                    Calls to sendNotification or to access the
                    facade will fail until after this method 
                    has been called.
                </para>
            </remarks>
            <param name="key">the multitonKey for this INotifier to use</param>
        </member>
        <member name="T:PureMVC.Interfaces.IObserver">
            <summary>
            The interface definition for a PureMVC Observer.
            </summary>
            <remarks>
                <para>
                    In PureMVC, the <c>Observer</c> class assumes these responsibilities:
                    <list type="bullet">
                        <item>Encapsulate the notification (callback) method of the interested object.</item>
                        <item>Encapsulate the notification context (this) of the interested object.</item>
                        <item>Provide methods for setting the notification method and context.</item>
                        <item>Provide a method for notifying the interested object.</item>
                    </list>
                </para>
                <para>
                    PureMVC does not rely upon underlying event models such 
                    as the one provided with Flash, and ActionScript 3 does 
                    not have an inherent event model.
                </para>
                <para>
                    The Observer Pattern as implemented within PureMVC exists 
                    to support event-driven communication between the 
                    application and the actors of the MVC triad.
                </para>
                <para>
                    An Observer is an object that encapsulates information
                    about an interested object with a notification method that
                    should be called when an <c>INotification</c> is broadcast. The Observer then
                    acts as a proxy for notifying the interested object.
                </para>
                <para>
                    Observers can receive <c>Notification</c>s by having their
                    <c>notifyObserver</c> method invoked, passing
                    in an object implementing the <c>INotification</c> interface, such
                    as a subclass of <c>Notification</c>.
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Interfaces.IView"/>
            <seealso cref="T:PureMVC.Interfaces.INotification"/>
        </member>
        <member name="P:PureMVC.Interfaces.IObserver.NotifyMethod">
            <summary>
            Set the notification method (callback) method of the interested object
            </summary>
            <remarks>
                <para>
                    The notification method should take one parameter of type <c>INotification</c>
                </para>
            </remarks>
        </member>
        <member name="P:PureMVC.Interfaces.IObserver.NotifyContext">
            <summary>
            Set the notification context (this) of the interested object
            </summary>
        </member>
        <member name="M:PureMVC.Interfaces.IObserver.NotifyObserver(PureMVC.Interfaces.INotification)">
            <summary>
            Notify the interested object.
            </summary>
            <param name="notification">the <c>INotification</c> to pass to the interested object's notification method</param>
        </member>
        <member name="M:PureMVC.Interfaces.IObserver.CompareNotifyContext(System.Object)">
            <summary>
            Compare the given object to the notificaiton context object.
            </summary>
            <param name="obj">the object to compare.</param>
            <returns>indicating if the notification context and the object are the same.</returns>
        </member>
        <member name="T:PureMVC.Interfaces.IProxy">
            <summary>
            The interface definition for a PureMVC Proxy.
            </summary>
            <remarks>
                <para>
                    In PureMVC, <c>IProxy</c> implementors assume these responsibilities:
                    <list type="bullet">
                        <item>Implement a common method which returns the name of the Proxy.</item>
                        <item>Provide methods for setting and getting the data object.</item>
                    </list>
                </para>
                <para>
                    Additionally, <c>IProxy</c>s typically:
                    <list type="bullet">
                        <item>Maintain references to one or more pieces of model data.</item>
                        <item>Provide methods for manipulating that data.</item>
                        <item>Generate <c>INotifications</c> when their model data changes.</item>
                        <item>Expose their name as a <c>public static const</c> called <c>NAME</c>, if they are not instantiated multiple times.</item>
                        <item>Encapsulate interaction with local or remote services used to fetch and persist model data.</item>
                    </list>
                </para>
            </remarks>
        </member>
        <member name="P:PureMVC.Interfaces.IProxy.ProxyName">
            <summary>
            Get the Proxy name
            </summary>
        </member>
        <member name="P:PureMVC.Interfaces.IProxy.Data">
            <summary>
            Get or Set the data object
            </summary>
        </member>
        <member name="M:PureMVC.Interfaces.IProxy.OnRegister">
            <summary>
            Called by the Model when the Proxy is registered
            </summary>
        </member>
        <member name="M:PureMVC.Interfaces.IProxy.OnRemove">
            <summary>
            Called by the Model when the Proxy is removed
            </summary>
        </member>
        <member name="T:PureMVC.Interfaces.IView">
            <summary>
            The interface definition for a PureMVC View.
            </summary>
            <remarks>
                <para>In PureMVC, the <c>View</c> class assumes these responsibilities:</para>
                <list type="bullet">
                    <item>Maintain a cache of <c>IMediator</c> instances</item>
                    <item>Provide methods for registering, retrieving, and removing <c>IMediators</c></item>
                    <item>Managing the observer lists for each <c>INotification</c> in the application</item>
                    <item>Providing a method for attaching <c>IObservers</c> to an <c>INotification</c>'s observer list</item>
                    <item>Providing a method for broadcasting an <c>INotification</c></item>
                    <item>Notifying the <c>IObservers</c> of a given <c>INotification</c> when it broadcast</item>
                </list>
            </remarks>
            <seealso cref="T:PureMVC.Interfaces.IMediator"/>
            <seealso cref="T:PureMVC.Interfaces.IObserver"/>
            <seealso cref="T:PureMVC.Interfaces.INotification"/>
        </member>
        <member name="M:PureMVC.Interfaces.IView.RegisterObserver(System.String,PureMVC.Interfaces.IObserver)">
            <summary>
            Register an <c>IObserver</c> to be notified
            of <c>INotifications</c> with a given name.
            </summary>
            <param name="notificationName">the name of the <c>INotifications</c> to notify this <c>IObserver</c> of</param>
            <param name="observer">the <c>IObserver</c> to register</param>
        </member>
        <member name="M:PureMVC.Interfaces.IView.RemoveObserver(System.String,System.Object)">
            <summary>
            Remove a group of observers from the observer list for a given Notification name.
            </summary>
            <param name="notificationName">which observer list to remove from </param>
            <param name="notifyContext">removed the observers with this object as their notifyContext</param>
        </member>
        <member name="M:PureMVC.Interfaces.IView.NotifyObservers(PureMVC.Interfaces.INotification)">
            <summary>
            Notify the <c>IObservers</c> for a particular <c>INotification</c>.
            </summary>
            <remarks>
                <para>
                    All previously attached <c>IObservers</c> for this <c>INotification</c>'s
                    list are notified and are passed a reference to the <c>INotification</c> in 
                    the order in which they were registered.
                </para>
            </remarks>
            <param name="notification">the <c>INotification</c> to notify <c>IObservers</c> of.</param>
        </member>
        <member name="M:PureMVC.Interfaces.IView.RegisterMediator(PureMVC.Interfaces.IMediator)">
            <summary>
            Register an <c>IMediator</c> instance with the <c>View</c>.
            </summary>
            <remarks>
                <para>
                    Registers the <c>IMediator</c> so that it can be retrieved by name,
                    and further interrogates the <c>IMediator</c> for its 
                    <c>INotification</c> interests.
                </para>
                <para>
                    If the <c>IMediator</c> returns any <c>INotification</c> 
                    names to be notified about, an <c>Observer</c> is created encapsulating 
                    the <c>IMediator</c> instance's <c>handleNotification</c> method 
                    and registering it as an <c>Observer</c> for all <c>INotifications</c> the 
                    <c>IMediator</c> is interested in.
                </para>
            </remarks>
            <param name="mediator">a reference to the <c>IMediator</c> instance</param>
        </member>
        <member name="M:PureMVC.Interfaces.IView.RetrieveMediator(System.String)">
            <summary>
            Retrieve an <c>IMediator</c> from the <c>View</c>.
            </summary>
            <param name="mediatorName">the name of the <c>IMediator</c> instance to retrieve.</param>
            <returns>the <c>IMediator</c> instance previously registered with the given <c>mediatorName</c>.</returns>
        </member>
        <member name="M:PureMVC.Interfaces.IView.RemoveMediator(System.String)">
            <summary>
            Remove an <c>IMediator</c> from the <c>View</c>.
            </summary>
            <param name="mediatorName">name of the <c>IMediator</c> instance to be removed.</param>
            <returns>the <c>IMediator</c> that was removed from the <c>View</c></returns>
        </member>
        <member name="M:PureMVC.Interfaces.IView.HasMediator(System.String)">
            <summary>
            Check if a Mediator is registered or not
            </summary>
            <param name="mediatorName"></param>
            <returns>whether a Mediator is registered with the given <c>mediatorName</c>.</returns>
        </member>
        <member name="T:PureMVC.Patterns.Command.MacroCommand">
            <summary>
            A base <c>ICommand</c> implementation that executes other <c>ICommand</c>s.
            </summary>
            <remarks>
                <para>
                    A <c>MacroCommand</c> maintains an list of
                    <c>ICommand</c> Class references called <i>SubCommands</i>.
                </para>
                <para>
                    When <c>execute</c> is called, the <c>MacroCommand</c> 
                    instantiates and calls <c>execute</c> on each of its <i>SubCommands</i> turn.
                    Each <i>SubCommand</i> will be passed a reference to the original
                    <c>INotification</c> that was passed to the <c>MacroCommand</c>'s 
                    <c>execute</c> method.
                </para>
                <para>
                    Unlike <c>SimpleCommand</c>, your subclass
                    should not override <c>execute</c>, but instead, should 
                    override the <c>initializeMacroCommand</c> method, 
                    calling <c>addSubCommand</c> once for each <i>SubCommand</i>
                    to be executed.
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Core.Controller"/>
            <seealso cref="T:PureMVC.Patterns.Observer.Notification"/>
            <seealso cref="T:PureMVC.Patterns.Command.SimpleCommand"/>
        </member>
        <member name="M:PureMVC.Patterns.Command.MacroCommand.#ctor">
            <summary>
            Constructor.
            </summary>
            <remarks>
                <para>
                    You should not need to define a constructor, 
                    instead, override the <c>initializeMacroCommand</c>
                    method.
                </para>
                <para>
                    If your subclass does define a constructor, be 
                    sure to call <c>super()</c>.
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Patterns.Command.MacroCommand.InitializeMacroCommand">
            <summary>
            Initialize the <c>MacroCommand</c>.
            </summary>
            <remarks>
                <para>
                    In your subclass, override this method to 
                    initialize the <c>MacroCommand</c>'s <i>SubCommand</i>  
                    list with <c>ICommand</c> class references like
                    this:
                </para>
                <example>
                    <code>
                        override void InitializeMacroCommand() 
                        {
                            AddSubCommand(() => new com.me.myapp.controller.FirstCommand());
                            AddSubCommand(() => new com.me.myapp.controller.SecondCommand());
                            AddSubCommand(() => new com.me.myapp.controller.ThirdCommand());
                        }
                    </code>
                </example>
                <para>
                    Note that <i>SubCommand</i>s may be any <c>ICommand</c> implementor,
                    <c>MacroCommand</c>s or <c>SimpleCommands</c> are both acceptable.
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Patterns.Command.MacroCommand.AddSubCommand(System.Func{PureMVC.Interfaces.ICommand})">
            <summary>
            Add a <c>SubCommand</c>.
            </summary>
            <remarks>
                <para>
                    The <i>SubCommands</i> will be called in First In/First Out (FIFO)
                    order.
                </para>
            </remarks>
            <param name="commandClassRef">a reference to the <c>FuncDelegate</c> of the <c>ICommand</c>.</param>
        </member>
        <member name="M:PureMVC.Patterns.Command.MacroCommand.Execute(PureMVC.Interfaces.INotification)">
            <summary>
            Execute this <c>MacroCommand</c>'s <i>SubCommands</i>.
            </summary>
            <remarks>
                <para>
                    The <i>SubCommands</i> will be called in First In/First Out (FIFO)
                    order.
                </para>
            </remarks>
            <param name="notification">the <c>INotification</c> object to be passsed to each <i>SubCommand</i>.</param>
        </member>
        <member name="F:PureMVC.Patterns.Command.MacroCommand.subcommands">
            <summary>List of subcommands</summary>
        </member>
        <member name="T:PureMVC.Patterns.Command.SimpleCommand">
            <summary>
            A base <c>ICommand</c> implementation.
            </summary>
            <remarks>
                <para>
                    Your subclass should override the <c>execute</c> 
                    method where your business logic will handle the <c>INotification</c>. 
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Core.Controller"/>
            <seealso cref="T:PureMVC.Patterns.Observer.Notification"/>
            <seealso cref="T:PureMVC.Patterns.Command.MacroCommand"/>
        </member>
        <member name="M:PureMVC.Patterns.Command.SimpleCommand.Execute(PureMVC.Interfaces.INotification)">
            <summary>
            Fulfill the use-case initiated by the given <c>INotification</c>.
            </summary>
            <remarks>
                <para>
                    In the Command Pattern, an application use-case typically
                    begins with some user action, which results in an <c>INotification</c> being broadcast, which 
                    is handled by business logic in the <c>execute</c> method of an
                    <c>ICommand</c>.
                </para>
            </remarks>
            <param name="notification">the <c>INotification</c> to handle.</param>
        </member>
        <member name="T:PureMVC.Patterns.Facade.Facade">
            <summary>
            A base Multiton <c>IFacade</c> implementation.
            </summary>
            <seealso cref="T:PureMVC.Core.Model"/>
            <seealso cref="T:PureMVC.Core.View"/>
            <seealso cref="T:PureMVC.Core.Controller"/>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <remarks>
                <para>
                    This <c>IFacade</c> implementation is a Multiton, 
                    so you should not call the constructor 
                    directly, but instead call the static Factory method, 
                    passing the unique key for this instance 
                    <c>Facade.getInstance( multitonKey, () => new Facade(multitonKey) )</c>
                </para>
            </remarks>
            <param name="key">Key of view</param>
            <exception cref="T:System.Exception">Thrown if instance for this Multiton key has already been constructed</exception>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.InitializeFacade">
            <summary>
            Initialize the Multiton <c>Facade</c> instance.
            </summary>
            <remarks>
                <para>
                    Called automatically by the constructor. Override in your
                    subclass to do any subclass specific initializations. Be
                    sure to call <c>super.initializeFacade()</c>, though.
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.GetInstance(System.String,System.Func{PureMVC.Interfaces.IFacade})">
            <summary>
            Facade Multiton Factory method
            </summary>
            <param name="key">Key of facade</param>
            <param name="facadeClassRef">the <c>FuncDelegate</c> of the <c>IFacade</c></param>
            <returns>the Multiton instance of the Facade</returns>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.InitializeController">
            <summary>
            Initialize the <c>Controller</c>.
            </summary>
            <remarks>
                <para>
                    Called by the <c>initializeFacade</c> method.
                    Override this method in your subclass of <c>Facade</c> 
                    if one or both of the following are true:
                    <list type="bullet">
                        <item>You wish to initialize a different <c>IController</c>.</item>
                        <item>You have <c>Commands</c> to register with the <c>Controller</c> at startup.</item>
                    </list>
                </para>
                <para>
                    If you don't want to initialize a different <c>IController</c>, 
                    call <c>super.initializeController()</c> at the beginning of your
                    method, then register <c>Command</c>s.
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.InitializeModel">
            <summary>
            Initialize the <c>Model</c>.
            </summary>
            <remarks>
                <para>
                    Called by the <c>initializeFacade</c> method.
                    Override this method in your subclass of <c>Facade</c> 
                    if one or both of the following are true:
                    <list type="bullet">
                        <item>You wish to initialize a different <c>IModel</c>.</item>
                        <item>You have <c>Proxy</c>s to register with the <c>Model</c> that do not
                            retrieve a reference to the Facade at construction time.
                        </item>
                    </list>
                </para>
                <para>
                    If you don't want to initialize a different <c>IModel</c>, 
                    call <c>super.initializeModel()</c> at the beginning of your
                    method, then register <c>Proxy</c>s.
                </para>
                <para>
                    Note: This method is <i>rarely</i> overridden; in practice you are more
                    likely to use a <c>Command</c> to create and register <c>Proxy</c>s
                    with the <c>Model</c>, since <c>Proxy</c>s with mutable data will likely
                    need to send <c>INotification</c>s and thus will likely want to fetch a reference to 
                    the <c>Facade</c> during their construction. 
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.InitializeView">
            <summary>
            Initialize the <c>View</c>.
            </summary>
            <remarks>
                <para>
                    Called by the <c>initializeFacade</c> method.
                    Override this method in your subclass of <c>Facade</c> 
                    if one or both of the following are true:
                    <list type="bullet">
                        <item>You wish to initialize a different <c>IView</c>.</item>
                        <item>You have <c>Observers</c> to register with the <c>View</c></item>
                    </list>
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.RegisterCommand(System.String,System.Func{PureMVC.Interfaces.ICommand})">
            <summary>
            Register an <c>ICommand</c> with the <c>Controller</c> by Notification name.
            </summary>
            <param name="notificationName">the name of the <c>INotification</c> to associate the <c>ICommand</c> with</param>
            <param name="commandClassRef">a reference to the Class of the <c>ICommand</c></param>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.RemoveCommand(System.String)">
            <summary>
            Remove a previously registered <c>ICommand</c> to <c>INotification</c> mapping from the Controller.
            </summary>
            <param name="notificationName">the name of the <c>INotification</c> to remove the <c>ICommand</c> mapping for</param>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.HasCommand(System.String)">
            <summary>
            Check if a Command is registered for a given Notification 
            </summary>
            <param name="notificationName"></param>
            <returns>whether a Command is currently registered for the given <c>notificationName</c>.</returns>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.RegisterProxy(PureMVC.Interfaces.IProxy)">
            <summary>
            Register an <c>IProxy</c> with the <c>Model</c> by name.
            </summary>
            <param name="proxy">the <c>IProxy</c> instance to be registered with the <c>Model</c>.</param>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.RetrieveProxy(System.String)">
            <summary>
            Retrieve an <c>IProxy</c> from the <c>Model</c> by name.
            </summary>
            <param name="proxyName">the name of the proxy to be retrieved.</param>
            <returns>the <c>IProxy</c> instance previously registered with the given <c>proxyName</c>.</returns>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.RemoveProxy(System.String)">
            <summary>
            Remove an <c>IProxy</c> from the <c>Model</c> by name.
            </summary>
            <param name="proxyName">the <c>IProxy</c> to remove from the <c>Model</c>.</param>
            <returns>the <c>IProxy</c> that was removed from the <c>Model</c></returns>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.HasProxy(System.String)">
            <summary>
            Check if a Proxy is registered
            </summary>
            <param name="proxyName"></param>
            <returns>whether a Proxy is currently registered with the given <c>proxyName</c>.</returns>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.RegisterMediator(PureMVC.Interfaces.IMediator)">
            <summary>
            Register a <c>IMediator</c> with the <c>View</c>.
            </summary>
            <param name="mediator">a reference to the <c>IMediator</c></param>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.RetrieveMediator(System.String)">
            <summary>
            Retrieve an <c>IMediator</c> from the <c>View</c>.
            </summary>
            <param name="mediatorName"></param>
            <returns>the <c>IMediator</c> previously registered with the given <c>mediatorName</c>.</returns>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.RemoveMediator(System.String)">
            <summary>
            Remove an <c>IMediator</c> from the <c>View</c>.
            </summary>
            <param name="mediatorName">name of the <c>IMediator</c> to be removed.</param>
            <returns>the <c>IMediator</c> that was removed from the <c>View</c></returns>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.HasMediator(System.String)">
            <summary>
            Check if a Mediator is registered or not
            </summary>
            <param name="mediatorName"></param>
            <returns>whether a Mediator is registered with the given <c>mediatorName</c>.</returns>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.SendNotification(System.String,System.Object,System.String)">
            <summary>
            Create and send an <c>INotification</c>.
            </summary>
            <remarks>
                <para>
                    Keeps us from having to construct new notification 
                    instances in our implementation code.
                </para>
            </remarks>
            <param name="notificationName">the name of the notiification to send</param>
            <param name="body">the body of the notification (optional)</param>
            <param name="type">type the type of the notification (optional)</param>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.NotifyObservers(PureMVC.Interfaces.INotification)">
            <summary>
            Notify <c>Observer</c>s.
            </summary>
            <remarks>
                <para>
                    This method is left public mostly for backward 
                    compatibility, and to allow you to send custom 
                    notification classes using the facade.
                </para>
                <para>
                    Usually you should just call sendNotification
                    and pass the parameters, never having to 
                    construct the notification yourself.
                </para>
            </remarks>
            <param name="notification">the <c>INotification</c> to have the <c>View</c> notify <c>Observers</c> of.</param>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.InitializeNotifier(System.String)">
            <summary>
            Set the Multiton key for this facade instance.
            </summary>
            <remarks>
                <para>
                    Not called directly, but instead from the 
                    constructor when getInstance is invoked.
                    It is necessary to be public in order to 
                    implement INotifier.
                </para>
            </remarks>
            <param name="key"></param>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.HasCore(System.String)">
            <summary>
             Check if a Core is registered or not
            </summary>
            <param name="key">the multiton key for the Core in question</param>
            <returns>whether a Core is registered with the given <c>key</c>.</returns>
        </member>
        <member name="M:PureMVC.Patterns.Facade.Facade.RemoveCore(System.String)">
            <summary>
            Remove a Core.
            </summary>
            <remarks>
                <para>
                    Remove the Model, View, Controller and Facade 
                    instances for the given key.
                </para>
            </remarks>
            <param name="key">multitonKey of the Core to remove</param>
        </member>
        <member name="F:PureMVC.Patterns.Facade.Facade.controller">
            <summary>References to Controller</summary>
        </member>
        <member name="F:PureMVC.Patterns.Facade.Facade.model">
            <summary>References to Model</summary>
        </member>
        <member name="F:PureMVC.Patterns.Facade.Facade.view">
            <summary>References to View</summary>
        </member>
        <member name="F:PureMVC.Patterns.Facade.Facade.multitonKey">
            <summary>The Multiton Key for this app</summary>
        </member>
        <member name="F:PureMVC.Patterns.Facade.Facade.instanceMap">
            <summary>The Multiton Facade instanceMap.</summary>
        </member>
        <member name="F:PureMVC.Patterns.Facade.Facade.MULTITON_MSG">
            <summary>Message Constants</summary>
        </member>
        <member name="T:PureMVC.Patterns.Mediator.Mediator">
            <summary>
            A base <c>IMediator</c> implementation. 
            </summary>
            <seealso cref="T:PureMVC.Core.View"/>
        </member>
        <member name="F:PureMVC.Patterns.Mediator.Mediator.NAME">
            <summary>
            The name of the <c>Mediator</c>. 
            </summary>
            <remarks>
                <para>
                    Typically, a <c>Mediator</c> will be written to serve
                    one specific control or group controls and so,
                    will not have a need to be dynamically named.
                </para>
            </remarks>
        </member>
        <member name="M:PureMVC.Patterns.Mediator.Mediator.#ctor(System.String,System.Object)">
            <summary>
            Constructor.
            </summary>
            <param name="mediatorName"></param>
            <param name="viewComponent"></param>
        </member>
        <member name="M:PureMVC.Patterns.Mediator.Mediator.ListNotificationInterests">
            <summary>
            List the <c>INotification</c> names this
            <c>Mediator</c> is interested in being notified of.
            </summary>
            <returns>the list of <c>INotification</c> names</returns>
        </member>
        <member name="M:PureMVC.Patterns.Mediator.Mediator.HandleNotification(PureMVC.Interfaces.INotification)">
            <summary>
            Handle <c>INotification</c>s.
            </summary>
            <remarks>
                <para>
                    Typically this will be handled in a switch statement,
                    with one 'case' entry per <c>INotification</c>
                    the <c>Mediator</c> is interested in.
                </para>
            </remarks>
            <param name="notification"></param>
        </member>
        <member name="M:PureMVC.Patterns.Mediator.Mediator.OnRegister">
            <summary>
            Called by the View when the Mediator is registered
            </summary>
        </member>
        <member name="M:PureMVC.Patterns.Mediator.Mediator.OnRemove">
            <summary>
            Called by the View when the Mediator is removed
            </summary>
        </member>
        <member name="P:PureMVC.Patterns.Mediator.Mediator.MediatorName">
            <summary>the mediator name</summary>
        </member>
        <member name="P:PureMVC.Patterns.Mediator.Mediator.ViewComponent">
            <summary>The view component</summary>
        </member>
        <member name="T:PureMVC.Patterns.Observer.Notification">
            <summary>
            A base <c>INotification</c> implementation.
            </summary>
            <remarks>
                <para>
                    PureMVC does not rely upon underlying event models such 
                    as the one provided with Flash, and ActionScript 3 does 
                    not have an inherent event model.
                </para>
                <para>
                    The Observer Pattern as implemented within PureMVC exists 
                    to support event-driven communication between the 
                    application and the actors of the MVC triad.
                </para>
                <para>
                    Notifications are not meant to be a replacement for Events
                    in Flex/Flash/Apollo. Generally, <c>IMediator</c> implementors
                    place event listeners on their view components, which they
                    then handle in the usual way. This may lead to the broadcast of <c>Notification</c>s to 
                    trigger <c>ICommand</c>s or to communicate with other <c>IMediators</c>. 
                    <c>IProxy</c> and <c>ICommand</c>
                    instances communicate with each other and <c>IMediator</c>s
                    by broadcasting <c>INotification</c>s.
                </para>
                <para>
                    A key difference between Flash <c>Event</c>s and PureMVC
                    <c>Notification</c>s is that <c>Event</c>s follow the 
                    'Chain of Responsibility' pattern, 'bubbling' up the display hierarchy 
                    until some parent component handles the <c>Event</c>, while
                    PureMVC <c>Notification</c>s follow a 'Publish/Subscribe'
                    pattern. PureMVC classes need not be related to each other in a 
                    parent/child relationship in order to communicate with one another
                    using <c>Notification</c>s.
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Patterns.Observer.Observer"/>
        </member>
        <member name="M:PureMVC.Patterns.Observer.Notification.#ctor(System.String,System.Object,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">name of the <c>Notification</c> instance. (required)</param>
            <param name="body">the <c>Notification</c> body. (optional)</param>
            <param name="type">the type of the <c>Notification</c> (optional)</param>
        </member>
        <member name="M:PureMVC.Patterns.Observer.Notification.ToString">
            <summary>
            Get the string representation of the <c>Notification</c> instance.
            </summary>
            <returns>the string representation of the <c>Notification</c> instance.</returns>
        </member>
        <member name="P:PureMVC.Patterns.Observer.Notification.Name">
            <summary>the name of the notification instance</summary>
        </member>
        <member name="P:PureMVC.Patterns.Observer.Notification.Body">
            <summary>the body of the notification instance</summary>
        </member>
        <member name="P:PureMVC.Patterns.Observer.Notification.Type">
            <summary>the type of the notification instance</summary>
        </member>
        <member name="T:PureMVC.Patterns.Observer.Notifier">
            <summary>
            A Base <c>INotifier</c> implementation.
            </summary>
            <remarks>
                <para>
                    <c>MacroCommand, Command, Mediator</c> and <c>Proxy</c> 
                    all have a need to send <c>Notifications</c>.
                </para>
                <para>
                    The <c>INotifier</c> interface provides a common method called
                    <c>sendNotification</c> that relieves implementation code of 
                    the necessity to actually construct <c>Notifications</c>.
                </para>
                <para>
                    The <c>Notifier</c> class, which all of the above mentioned classes
                    extend, provides an initialized reference to the <c>Facade</c>
                    Multiton, which is required for the convienience method
                    for sending <c>Notifications</c>, but also eases implementation as these
                    classes have frequent <c>Facade</c> interactions and usually require
                    access to the facade anyway.
                </para>
                <para>
                    NOTE: In the MultiCore version of the framework, there is one caveat to
                    notifiers, they cannot send notifications or reach the facade until they
                    have a valid multitonKey.
                    The multitonKey is set:
                    <list type="bullet">
                        <item>on a Command when it is executed by the Controller</item>
                        <item>on a Mediator is registered with the View</item>
                        <item>on a Proxy is registered with the Model.</item>
                    </list>
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Patterns.Proxy.Proxy"/>
            <seealso cref="T:PureMVC.Patterns.Facade.Facade"/>
            <seealso cref="T:PureMVC.Patterns.Mediator.Mediator"/>
            <seealso cref="T:PureMVC.Patterns.Command.MacroCommand"/>
            <seealso cref="T:PureMVC.Patterns.Command.SimpleCommand"/>
        </member>
        <member name="M:PureMVC.Patterns.Observer.Notifier.SendNotification(System.String,System.Object,System.String)">
            <summary>
            Create and send an <c>INotification</c>.
            </summary>
            <remarks>
                <para>
                    Keeps us from having to construct new INotification 
                    instances in our implementation code.
                </para>
            </remarks>
            <param name="notificationName">the name of the notiification to send</param>
            <param name="body">the body of the notification (optional)</param>
            <param name="type">the type of the notification (optional)</param>
        </member>
        <member name="M:PureMVC.Patterns.Observer.Notifier.InitializeNotifier(System.String)">
            <summary>
            Initialize this INotifier instance.
            </summary>
            <remarks>
                <para>
                    This is how a Notifier gets its multitonKey. 
                    Calls to sendNotification or to access the
                    facade will fail until after this method 
                    has been called.
                </para>
                <para>
                    Mediators, Commands or Proxies may override 
                    this method in order to send notifications
                    or access the Multiton Facade instance as
                    soon as possible. They CANNOT access the facade
                    in their constructors, since this method will not
                    yet have been called.
                </para>
            </remarks>
            <param name="key">the multitonKey for this INotifier to use</param>
        </member>
        <member name="P:PureMVC.Patterns.Observer.Notifier.Facade">
            <summary> Return the Multiton Facade instance</summary>
        </member>
        <member name="P:PureMVC.Patterns.Observer.Notifier.MultitonKey">
            <summary>The Multiton Key for this app</summary>
        </member>
        <member name="F:PureMVC.Patterns.Observer.Notifier.MULTITON_MSG">
            <summary>Message Constants</summary>
        </member>
        <member name="T:PureMVC.Patterns.Observer.Observer">
            <summary>
            A base <c>IObserver</c> implementation.
            </summary>
            <remarks>
                <para>
                    An <c>Observer</c> is an object that encapsulates information
                    about an interested object with a method that should 
                    be called when a particular <c>INotification</c> is broadcast. 
                </para>
                <para>
                    In PureMVC, the <c>Observer</c> class assumes these responsibilities:
                    <list type="bullet">
                        <item>Encapsulate the notification (callback) method of the interested object.</item>
                        <item>Encapsulate the notification context (this) of the interested object.</item>
                        <item>Provide methods for setting the notification method and context.</item>
                        <item>Provide a method for notifying the interested object.</item>
                    </list>
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Core.View"/>
            <seealso cref="T:PureMVC.Patterns.Observer.Notification"/>
        </member>
        <member name="M:PureMVC.Patterns.Observer.Observer.#ctor(System.Action{PureMVC.Interfaces.INotification},System.Object)">
            <summary>
            Constructor.
            </summary>
            <remarks>
                <para>
                    The notification method on the interested object should take 
                    one parameter of type <c>INotification</c>
                </para>
            </remarks>
            <param name="notifyMethod">the notification method of the interested object</param>
            <param name="notifyContext">the notification context of the interested object</param>
        </member>
        <member name="M:PureMVC.Patterns.Observer.Observer.NotifyObserver(PureMVC.Interfaces.INotification)">
            <summary>
            Notify the interested object.
            </summary>
            <param name="Notification">the <c>INotification</c> to pass to the interested object's notification method.</param>
        </member>
        <member name="M:PureMVC.Patterns.Observer.Observer.CompareNotifyContext(System.Object)">
            <summary>
            Compare an object to the notification context. 
            </summary>
            <param name="obj">the object to compare</param>
            <returns>indicating if the object and the notification context are the same</returns>
        </member>
        <member name="P:PureMVC.Patterns.Observer.Observer.NotifyMethod">
            <summary>Callback method</summary>
        </member>
        <member name="P:PureMVC.Patterns.Observer.Observer.NotifyContext">
            <summary>Context object</summary>
        </member>
        <member name="T:PureMVC.Patterns.Proxy.Proxy">
            <summary>
            A base <c>IProxy</c> implementation. 
            </summary>
            <remarks>
                <para>
                    In PureMVC, <c>Proxy</c> classes are used to manage parts of the 
                    application's data model.
                </para>
                <para>
                     A <c>Proxy</c> might simply manage a reference to a local data object, 
                     in which case interacting with it might involve setting and 
                     getting of its data in synchronous fashion.
                </para>
                <para>
                    <c>Proxy</c> classes are also used to encapsulate the application's 
                    interaction with remote services to save or retrieve data, in which case,
                    we adopt an asyncronous idiom; setting data (or calling a method) on the 
                    <c>Proxy</c> and listening for a <c>Notification</c> to be sent 
                    when the <c>Proxy</c> has retrieved the data from the service.
                </para>
            </remarks>
            <seealso cref="T:PureMVC.Core.Model"/>
        </member>
        <member name="F:PureMVC.Patterns.Proxy.Proxy.NAME">
            <summary>Name of the proxy</summary>
        </member>
        <member name="M:PureMVC.Patterns.Proxy.Proxy.#ctor(System.String,System.Object)">
            <summary>
            Constructor.
            </summary>
            <param name="proxyName"></param>
            <param name="data"></param>
        </member>
        <member name="M:PureMVC.Patterns.Proxy.Proxy.OnRegister">
            <summary>
            Called by the Model when the Proxy is registered
            </summary>
        </member>
        <member name="M:PureMVC.Patterns.Proxy.Proxy.OnRemove">
            <summary>
            Called by the Model when the Proxy is removed
            </summary>
        </member>
        <member name="P:PureMVC.Patterns.Proxy.Proxy.ProxyName">
            <summary>the proxy name</summary>
        </member>
        <member name="P:PureMVC.Patterns.Proxy.Proxy.Data">
            <summary>the proxy name</summary>
        </member>
    </members>
</doc>
